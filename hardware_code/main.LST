C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\keil_class\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #define MAIN_Fosc   22118400L //定义主时钟
   2          
   3          #include  "STC15Fxxxx.H"
   4          
   5          
   6          
   7          
   8          /***********************************************************/
   9          
  10          #define DIS_DOT   0x20
  11          #define DIS_BLACK 0x10
  12          #define DIS_    0x11
  13          
  14          
  15          /****************************** 用户定义宏 ***********************************/
  16          
  17          
  18          #define Timer0_Reload (65536UL -(MAIN_Fosc / 1000))   //Timer 0 中断频率, 1000次/秒
  19          
  20          /*****************************************************************************/
  21          
  22          
  23          
  24          
  25          /*************  本地常量声明  **************/
  26          u8 code t_display[]={           //标准字库
  27          //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
  28            0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
  29          //black  -     H    J  K    L    N  o   P  U     t    G    Q    r   M    y
  30            0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
  31            0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};  //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1
  32          
  33          u8 code T_COM[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};    //位码
  34          u8 day_num[]={31,28,31,30,31,30,31,31,30,31,30,31};
  35          
  36          /*************  IO口定义  **************/
  37          sbit  P_HC595_SER   = P4^0; //pin 14  SER   data input
  38          sbit  P_HC595_RCLK  = P5^4; //pin 12  RCLk  store (latch) clock
  39          sbit  P_HC595_SRCLK = P4^3; //pin 11  SRCLK Shift data clock
  40          
  41          
  42          /*************  本地变量声明  **************/
  43          
  44          u8  LED8[8];    //显示缓冲
  45          
  46          u8  display_index;  //显示位索引
  47          bit B_1ms;      //1ms标志
  48          
  49          u8  IO_KeyState, IO_KeyState1, IO_KeyHoldCnt; //行列键盘变量
  50          u8  KeyHoldCnt; //键按下计时
  51          u8  KeyCode;  //给用户使用的键码, 1~16有效
  52          u8  cnt50ms;
  53          u8  try,able;
  54          
  55          u8  month,day,hour,minute,second; //RTC变量
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 2   

  56          u8  curr_input;
  57          u8  key[] = {0, 0, 0, 0, 0, 0, 0, 0};
  58          u8  standard[] = {1, 2, 3, 4};
  59          u8  curr_show;  // 0显示时间，1显示日期，2显示温度
  60          u8  open;
  61          u16 year;
  62          u16 msecond, opentime, trytime;
  63          
  64          //记录当前状态
  65          u8 curr_state;   //0代表正常，关闭;1代表正常，开启；2代表异常，关闭（密码输错多次/异常情况）
  66           
  67          
  68          /*************  本地函数声明  **************/
  69          void  CalculateAdcKey(u16 adc);
  70          void  Display(u8 curr_show);
  71          void  IO_KeyScan(void); //50ms call
  72          void  WriteNbyte(u8 addr, u8 *p, u8 number);
  73          void  ReadNbyte( u8 addr, u8 *p, u8 number);
  74          void  DisplayTime(void);
  75          void  DisplayDate(void);
  76          void  DisplayTemp(void);
  77          void  DisplayKey(void);
  78          void  DisplayNewKey(void);
  79          void  reKey(void);
  80          void  changeDate(void);
  81          void  changing(u8 KeyCode, u8 curr_show);
  82          void  ReadRTC(void);
  83          void  WriteRTC(void);
  84          void  alert(u8 _code);
  85          void  delay_ms(u8 ms);
  86          u16   get_temperature(u16 adc);
  87          u16   Get_ADC10bitResult(u8 channel); //channel = 0~7
  88                                 
  89          /****************  外部函数声明和外部变量声明 *****************/
  90          
  91          
  92          /**********************************************/
  93          void main(void)
  94          {
  95   1        u8  i;
  96   1      
  97   1        P0M1 = 0; P0M0 = 0; //设置为准双向口
  98   1        P1M1 = 0; P1M0 = 0; //设置为准双向口
  99   1        P2M1 = 0; P2M0 = 0; //设置为准双向口
 100   1        P3M1 = 0; P3M0 = 0; //设置为准双向口
 101   1        P4M1 = 0; P4M0 = 0; //设置为准双向口
 102   1        P5M1 = 0; P5M0 = 0; //设置为准双向口
 103   1        P6M1 = 0; P6M0 = 0; //设置为准双向口
 104   1        P7M1 = 0; P7M0 = 0; //设置为准双向口
 105   1        
 106   1        P1ASF = 0x0C;   //P1.2 P1.3做ADC
 107   1        ADC_CONTR = 0xE0; //90T, ADC power on
 108   1        
 109   1        display_index = 0;
 110   1        curr_show = 0;
 111   1        curr_input = 0;
 112   1        curr_state = 0;
 113   1        opentime = 0;
 114   1        trytime = 0;
 115   1        AUXR = 0x80;  //Timer0 set as 1T, 16 bits timer auto-reload, 
 116   1        TH0 = (u8)(Timer0_Reload / 256);
 117   1        TL0 = (u8)(Timer0_Reload % 256);
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 3   

 118   1        ET0 = 1;  //Timer0 interrupt enable
 119   1        TR0 = 1;  //Tiner0 run
 120   1        EA = 1;   //打开总中断
 121   1        
 122   1        for(i=0; i<8; i++)  LED8[i] = 0x10; //上电消隐
 123   1      
 124   1        
 125   1        ReadRTC();
 126   1        F0 = 0;
 127   1        month = 1;
 128   1        year = 2019;
 129   1        day = 1;
 130   1        if(second >= 60)  F0 = 1; //错误
 131   1        if(minute >= 60)  F0 = 1; //错误
 132   1        if(hour   >= 24)  F0 = 1; //错误
 133   1        if(F0)  //有错误, 默认12:00:00
 134   1        {
 135   2          second = 0;
 136   2          minute = 0;
 137   2          hour  = 12;
 138   2          WriteRTC();
 139   2        }
 140   1      
 141   1        Display(curr_show);
 142   1        open = 0;
 143   1        try = 0;
 144   1        able = 1;
 145   1      
 146   1        KeyHoldCnt = 0; //键按下计时
 147   1        KeyCode = 0;  //给用户使用的键码, 1~16有效
 148   1      
 149   1        IO_KeyState = 0;
 150   1        IO_KeyState1 = 0;
 151   1        IO_KeyHoldCnt = 0;
 152   1        cnt50ms = 0;
 153   1        
 154   1        while(1)
 155   1        {
 156   2          if(B_1ms) //1ms到
 157   2          {
 158   3            if(open == 1) opentime++;
 159   3            else opentime = 0;
 160   3            if(opentime >= 2000) reKey();
 161   3            if(opentime >= 9000) alert(2);
 162   3            B_1ms = 0;
 163   3            if(try > 0 && try < 5) trytime++;
 164   3            if(trytime >= 20000){
 165   4                try = 0;
 166   4                trytime = 0;
 167   4            } 
 168   3            if(++msecond >= 1000) //1秒到
 169   3            {
 170   4              msecond = 0;
 171   4              changeDate();
 172   4              ReadRTC();
 173   4              Display(curr_show);
 174   4            }
 175   3      
 176   3            if(++cnt50ms >= 50)   //50ms扫描一次行列键盘
 177   3            {
 178   4              cnt50ms = 0;
 179   4              IO_KeyScan();
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 4   

 180   4            }
 181   3            
 182   3            if(KeyCode != 0)    //有键按下
 183   3            {
 184   4              if(KeyCode == 27) curr_show = 0; // 时钟模式
 185   4              if(KeyCode == 28) curr_show = 1; // 日期模式
 186   4              if(KeyCode == 29) curr_show = 2; // 温度模式
 187   4              if(KeyCode == 30 && curr_show != 3 && able == 1){   // 输入密码模式
 188   5                curr_show = 3; 
 189   5                curr_input = 0;
 190   5              } 
 191   4              if((KeyCode == 31 && curr_show != 4 && curr_show != 3 && able == 1) || (KeyCode == 31 && curr_show == 
             -3 && curr_input == 0 && able == 1)){
 192   5                curr_show = 4; 
 193   5                  curr_input = 0;
 194   5              }
 195   4           
 196   4              if(KeyCode >= 17 && KeyCode <= 26 && curr_show == 3 && curr_input < 4 && able == 1) //输入密码
 197   4              {
 198   5                LED8[curr_input+4] = KeyCode - 17;
 199   5                key[curr_input] = KeyCode - 17;
 200   5                curr_input++;
 201   5              }
 202   4              if(KeyCode >= 17 && KeyCode <= 26 && curr_show == 4 && curr_input < 8 && able == 1) //修改密码
 203   4              {
 204   5                LED8[curr_input] = KeyCode - 17;
 205   5                key[curr_input] = KeyCode - 17;
 206   5                curr_input++;
 207   5              }
 208   4              else if(KeyCode >= 17 && KeyCode <= 20 && curr_show != 3){  // 时间和日期的调整
 209   5                changing(KeyCode,curr_show);
 210   5              }
 211   4              if(KeyCode == 30 && curr_show == 3 && curr_input == 4 && able == 1){   // 输入密码模式，检测
 212   5                  if(standard[0] == key[0] && standard[1] == key[1]  && standard[2] == key[2] && standard[3] == key[
             -3]){//密码正确
 213   6                  P17 = 0;
 214   6                  P16 = 0;
 215   6                  P47 = 0;
 216   6                  P46 = 0;
 217   6                  open = 1;
 218   6                  curr_state = 1;
 219   6                  try = 0;
 220   6                }
 221   5                else{
 222   6                  alert(1);
 223   6                  if(++try >= 5){
 224   7                    alert(4);
 225   7                      able = 0;
 226   7                    curr_state = 2;
 227   7                  }
 228   6                  curr_input = 0;
 229   6                }
 230   5              }
 231   4              if(KeyCode == 31 && curr_show == 4 && curr_input == 8 && able == 1){   // 修改密码模式，检测
 232   5                  if(standard[0] == key[0] && standard[1] == key[1]  && standard[2] == key[2] && standard[3] == key[
             -3]){
 233   6                  try = 0;
 234   6                  reKey();
 235   6                  if(key[4] == 0 && key[5] == 0 && key[6] == 0 && key[7] == 0){
 236   7                    alert(3);
 237   7                  }
 238   6                  else{
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 5   

 239   7                    P17 = 0; P16 = 0;P47 = 0;P46 = 0;
 240   7                    standard[0] = key[4]; 
 241   7                    standard[1] = key[5]; 
 242   7                    standard[2] = key[6]; 
 243   7                    standard[3] = key[7];
 244   7                    delay_ms(1500);              
 245   7                    curr_show = 3;   
 246   7                  } 
 247   6                }
 248   5                
 249   5                else{
 250   6                  alert(1);
 251   6                  if(++try >= 5){
 252   7                    alert(4);
 253   7                    able = 0;
 254   7                  }
 255   6                  curr_input = 0;
 256   6                }
 257   5                
 258   5              }         
 259   4              if(KeyCode == 32){    // 撤销+关门+门锁复位
 260   5                
 261   5                if(curr_show == 3 && curr_input > 0 && able == 1){
 262   6                  key[curr_input-1] = 0;
 263   6                  LED8[curr_input+3] = DIS_;
 264   6                  curr_input--;
 265   6                }
 266   5                else if(curr_show == 4 && curr_input > 0 && able == 1) {
 267   6                  key[curr_input-1] = 0;
 268   6                  LED8[curr_input-1] = DIS_;
 269   6                  curr_input--;
 270   6                }
 271   5                else{
 272   6                  open = 0;
 273   6                  reKey();
 274   6                  curr_show = 0;
 275   6                }
 276   5        
 277   5              }  
 278   4      
 279   4              
 280   4      
 281   4              Display(curr_show);
 282   4              KeyCode = 0;
 283   4          
 284   4            }
 285   3      
 286   3          }
 287   2        }
 288   1      } 
 289          /******************************/
 290          void  changeDate(void){
 291   1        if(hour == 0 && minute == 0 && second == 0)
 292   1          changing(19,1);
 293   1      }
 294          void  changing(u8 KeyCode, u8 curr_show){
 295   1        if(curr_show == 0){
 296   2          if(KeyCode == 17){
 297   3            if(hour == 23){
 298   4              hour = 0;
 299   4              changing(19, 1);
 300   4            }
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 6   

 301   3            else{
 302   4               hour++;
 303   4            }
 304   3          }
 305   2          else if(KeyCode == 18){
 306   3            if(hour == 0){
 307   4              hour = 23;
 308   4              changing(20, 1);
 309   4            }
 310   3            else{
 311   4               hour--;
 312   4            }
 313   3          }
 314   2          else if (KeyCode == 19){
 315   3            if(minute == 59){
 316   4              minute = 0;
 317   4              changing(17, 0);
 318   4            }
 319   3            else minute++;
 320   3            second = 0;
 321   3          }
 322   2          else if (KeyCode == 20){
 323   3            if(minute == 0){
 324   4              minute = 59;
 325   4              changing(18, 0);
 326   4            }
 327   3            else minute--;
 328   3            second = 0;
 329   3          }
 330   2          WriteRTC();
 331   2        }
 332   1        else if(curr_show == 1){
 333   2          if(KeyCode == 17){
 334   3            if(month == 12){
 335   4              year++;
 336   4              month = 1;
 337   4            }
 338   3            else month++;
 339   3          }
 340   2          else if(KeyCode == 18){
 341   3            if(month == 1){
 342   4              year--;
 343   4              month = 12;
 344   4            }
 345   3            else{
 346   4              month--;
 347   4            }
 348   3          }
 349   2          else if(KeyCode == 19){
 350   3              if(day == day_num[month-1]){
 351   4              day = 1;
 352   4              changing(17, 1);
 353   4            }
 354   3            else{
 355   4              ++day;
 356   4            }
 357   3          }
 358   2          else if(KeyCode == 20){
 359   3            if(day == 1){
 360   4              changing(18, 1);
 361   4              day = day_num[month-1];
 362   4            }
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 7   

 363   3            else{
 364   4              day--;
 365   4            }
 366   3          }
 367   2        }
 368   1      }
 369          
 370          void alert(u8 _code){
 371   1        if(_code == 1){
 372   2          P17 = 0;
 373   2          P16 = 1;
 374   2          P47 = 1;
 375   2          P46 = 1;
 376   2        }
 377   1        if(_code == 2){
 378   2          P17 = 1;
 379   2          P16 = 0;
 380   2          P47 = 1;
 381   2          P46 = 1;
 382   2        }
 383   1        if(_code == 3){
 384   2          P17 = 1;
 385   2          P16 = 1;
 386   2          P47 = 0;
 387   2          P46 = 1;
 388   2        }
 389   1        if(_code == 4){
 390   2          while(1)
 391   2          {
 392   3            P17 = 0;
 393   3            delay_ms(250);
 394   3            delay_ms(250);
 395   3            P17 = 1;
 396   3            P16 = 0;
 397   3            delay_ms(250);
 398   3            delay_ms(250);
 399   3            P16 = 1;
 400   3            P47 = 0;
 401   3            delay_ms(250);
 402   3            delay_ms(250);
 403   3            P47 = 1;
 404   3            P46 = 0;
 405   3            delay_ms(250);
 406   3            delay_ms(250);
 407   3            P46 = 1;
 408   3          }
 409   2        }
 410   1      }
 411          
 412          void reKey(){
 413   1        P17 = 1;  
 414   1        P16 = 1;
 415   1        P47 = 1;
 416   1        P46 = 1; 
 417   1        key[0] = 0;
 418   1        key[1] = 0;
 419   1        key[2] = 0;
 420   1        key[3] = 0;
 421   1        key[4] = 0;
 422   1        key[5] = 0;
 423   1        key[6] = 0;
 424   1        key[7] = 0;
C51 COMPILER V9.01   MAIN                                                                  02/02/2019 20:55:11 PAGE 8   

 425   1        curr_input = 0;
 426   1      }
 427          
 428          
 429          
 430          
 431          /**************** 向HC595发送一个字节函数 ******************/
 432          void Send_595(u8 dat)
 433          {   
 434   1        u8  i;
 435   1        for(i=0; i<8; i++)
 436   1        {
 437   2          dat <<= 1;
 438   2          P_HC595_SER   = CY;
 439   2          P_HC595_SRCLK = 1;
 440   2          P_HC595_SRCLK = 0;
 441   2        }
 442   1      }
 443          
 444          /********************** 显示扫描函数 ************************/
 445          void DisplayScan(void)
 446          { 
 447   1        Send_595(~T_COM[display_index]);        //输出位码
 448   1        Send_595(t_display[LED8[display_index]]); //输出段码
 449   1      
 450   1        P_HC595_RCLK = 1;
 451   1        P_HC595_RCLK = 0;             //锁存输出数据
 452   1        if(++display_index >= 8)  display_index = 0;  //8位结束回0
 453   1      }
 454          
 455          
 456          /********************** Timer0 1ms中断函数 ************************/
 457          void timer0 (void) interrupt TIMER0_VECTOR
 458          {
 459   1        DisplayScan();  //1ms扫描显示一位
 460   1        B_1ms = 1;    //1ms标志
 461   1      }
 462          
 463          void  delay_ms(u8 ms)
 464          {
 465   1           u16 i;
 466   1         do{
 467   2              i = MAIN_Fosc / 13000;
 468   2            while(--i)  ;   //14T per loop
 469   2           }while(--ms);
 470   1      }
 471          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1332    ----
   CONSTANT SIZE    =     51    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
